#### 二分查找

- 针对排好序的数据集
- 每次把数据集分成两部分，对符合的那部分进行顺序查找
- 二分查找也是在不断缩小问题的规模，向基本情况靠近，且二分查找也在不断重复自身的步骤。因此，二分查找满足递归三定律，我们可以用递归来实现二分查找。
    - 递归算法总是涉及栈的使用，有爆栈的风险。一般来说，二分查找最好用迭代法来解决。
    - 在二分查找的递归版中，默认栈的使用是会消耗内存的，因而性能不如迭代版。
    - 二分查找看起来很好，但如果n（集合项数）很小，就不值得先排序再二分了，此时直接使用顺序查找可能更好。  
      此外对于很大的数据集，排序十分耗时且耗内存，直接使用顺序查找可能会更好。好在实际项目中大量的数据集不大也不小，非常适合二分查找。
- 普通二分查找（迭代法）和递归二分查找示例

``` rust
// 普通二分查找（迭代法）
fn binary_search1(nums: &[i32], num: &i32) -> bool {
    let mut low = 0;
    let mut high = nums.len() - 1;
    let mut found = false;

    while low <= high && !found {
        let mid: usize = (low + high) >> 1;
        println!("mid: {mid},{low}-{high}");
        // 若low + high可能溢出，则转换为减法
        // let mid: usize = low + ((high - low) >> 1);
        if *num == nums[mid] {
            found = true;
        } else if num < &nums[mid] {
            // num 小于中间值，省去后半部分的数据
            high = mid - 1;
        } else {
            // mid 大于或等于中间值，省去前半部分的数据
            low = mid + 1;
        }
    }
    found
}

// 递归法二分查找
fn binary_search2(nums: &[i32], num: &i32) -> bool {
    // 基本情况1：目标不存在
    if nums.len() == 0 { return false; }

    // 基本情况2: 目标存在
    let mid: usize = nums.len() >> 1;
    return if *num == nums[mid] {
        true
    } else if num < &nums[mid] {
        binary_search2(&nums[..mid], num)
    } else {
        binary_search2(&nums[mid + 1..], num)
    }
}

fn main() {
    let target = 8;
    let nums = [1, 2, 3, 5, 6, 8, 9, 11, 20, 24, 27, 32, 51, 68, 77, 98];
    let found = binary_search1(&nums, &target);
    println!("nums contains {target}: {found}");

    let found = binary_search2(&nums, &target);
    println!("nums contains {target}: {found}")
}
```

#### 二分查找变体-内插查找

- 内插查找是二分查找的一种变体，适合在有序数据集中进行查找。
- 如果数据是均匀分布的，那么使用内插查找可以快速比近代搜索的区域，从而提高查找效率。
- 内插查找不像二分查找那样只用中间项来界定，而是通过插值算法找到上/下界
- 个人理解：因为数据集是有序线性的，在坐标系中，会分不在一条直线上下，根据首位两项，画一条直线，  
  然后算出要查找的值对应的x坐标值，该值接近索引（如果该值在数据集中的话），这样来缩小查找范围。
- ![内插查找1.jpeg](..%2Fimages%2F%E5%86%85%E6%8F%92%E6%9F%A5%E6%89%BE1.jpeg)
- ![内插查找2.jpeg](..%2Fimages%2F%E5%86%85%E6%8F%92%E6%9F%A5%E6%89%BE2.jpeg)

#### 指数查找

- 指数查找是二分查找的另一个变体，其划分数据的方式不是使用平均值或插值，而是使用指数函数进行估计，
  这样可以快速找到上界，加快查找速度。指数查找适合已排序且无边界的数据，进而确认搜索区域，之后再在搜索区域内进行二分查找。
- 指数查找分两部分：
    - 找到上界，用于划分区间
    - 进行二分查找
- ![指数查找1.jpeg](..%2Fimages%2F%E6%8C%87%E6%95%B0%E6%9F%A5%E6%89%BE1.jpeg)
- ![指数查找2.jpeg](..%2Fimages%2F%E6%8C%87%E6%95%B0%E6%9F%A5%E6%89%BE2.jpeg)

#### 哈希查找

- 哈希查找是一种复杂度位O(1)的查找算法，也是最快的查找算法
- 负载因子：用λ表示，λ=项数/哈希表大小
    - 负载因子可以作为评估指标，尤其当程序需要保存很多数据项时。如果负载因子太大，则剩下的槽不够用，  
      可根据负载因子控制是否要将哈希表扩容。Rust、Go就是采用这种方式来库容哈希表。当负载因子超过阀值时，哈希表就开始扩容，为后面插入数据做准备。
- 哈希函数必须高效，以避免耗时成为主要部分。如果哈希函数太复杂，甚至比顺序查找和二分查找还耗时，比如打破打破哈希表O(1)
  复杂度，那就得不偿失了。
- 解决哈希冲突的另一种方法是拉链法。也就是说，每个冲突的位置设置一个冲突链表来保存数据项，查找时，发现冲突后，就到冲突链上进行顺序查找，
  此时复杂度为O(n)，当然，冲突链上的数据可以排序，然后借助二分查找，此时复杂度为O(log2(n))
  。如果冲突链太长，你还可以将冲突链改成红黑树，这样结构会更加稳定。拉链法是许多编程语言内置的解决哈希冲突的默认实现。
- 解决哈希冲突常见的方法：
    - 开放寻址法：解决哈希冲突时，查找哈希表并尝试找到下一个空槽来保存冲突项，找下一个空槽，可以顺序的方式查找直到遇到第一个空槽，也可以跳过若干槽，找到下一个空槽，这样可以更均匀的分散引起哈希冲突的数据项。
        - 在哈希表冲突后，寻找另一个槽的过程被称为重哈希（再哈希、重散列等），计算方法如下：
            - rehash(pos)=(pos+n)%size
    - 拉链法：在每个冲突位置，设置一个冲突链表（或数组）来保存数据项。查找时，发现冲突后，就到冲突链上进行顺序查找，冲突链上的数据可以排序，然后借助二分查找，如果冲突链太长，可以将冲突链改成红黑树，这样的结构会更加稳固。
    - 拉链法是许多编程语言内置的解决哈希冲突的默认实现。
- ![哈希查找1.jpeg](..%2Fimages%2F%E5%93%88%E5%B8%8C%E6%9F%A5%E6%89%BE1.jpeg)
- ![哈希查找2.jpeg](..%2Fimages%2F%E5%93%88%E5%B8%8C%E6%9F%A5%E6%89%BE2.jpeg)
- ![哈希查找3.jpeg](..%2Fimages%2F%E5%93%88%E5%B8%8C%E6%9F%A5%E6%89%BE3.jpeg)
- ![哈希查找4.jpeg](..%2Fimages%2F%E5%93%88%E5%B8%8C%E6%9F%A5%E6%89%BE4.jpeg)
- ![哈希查找5.jpeg](..%2Fimages%2F%E5%93%88%E5%B8%8C%E6%9F%A5%E6%89%BE5.jpeg)

#### Rust实现HashMap

- 在实施实现时可以采用两个Vec(Slot和data)来分别保存键和值，data保存值，slot保存键
- ![HashMap实现0.jpeg](..%2Fimages%2FHashMap%E5%AE%9E%E7%8E%B00.jpeg)
- ![HashMap实现1.jpeg](..%2Fimages%2FHashMap%E5%AE%9E%E7%8E%B01.jpeg)
- ![HashMap实现2.jpeg](..%2Fimages%2FHashMap%E5%AE%9E%E7%8E%B02.jpeg)
- ![HasnMap实现3.jpeg](..%2Fimages%2FHasnMap%E5%AE%9E%E7%8E%B03.jpeg)
- ![HashMap实现4.jpeg](..%2Fimages%2FHashMap%E5%AE%9E%E7%8E%B04.jpeg)

